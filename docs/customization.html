<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <link rel="stylesheet" type="text/css" href="/style.css">
  <link rel="icon" type="image/x-icon" href="data:,">
  <title>aretext : customization</title>
</head>
<body>
<h1 id="customization">Customization</h1>

<p>This guide describes how to customize aretext for your workflows.</p>

<p>Aretext uses a <a href="#configuration-rules">rule-based system for configuration</a>. This allows you to easily customize the editor for different programming languages and projects.</p>

<p>In addition, you can define <a href="#custom-menu-commands">custom menu commands</a> that invoke arbitrary programs. This provides a simple yet powerful way to extend the editor. For example, you can create custom menu commands to:</p>

<ul>
<li><a href="#example-make">Build a project with make</a></li>
<li><a href="#example-copy-and-paste-using-the-system-clipboard">Copy and paste using the system clipboard</a></li>
<li><a href="#example-format-current-file">Format a file</a></li>
<li><a href="#example-insert-snippet">Insert a snippet</a></li>
<li><a href="#example-grep">Search a project with grep</a></li>
<li><a href="#example-split-tmux-window">Open the current document in a new tmux window</a></li>
</ul>

<p>... and much more!</p>

<h2 id="configuration-rules">Configuration rules</h2>

<p>Aretext stores its configuration in a single YAML file. You can edit the config file using the <code>-editconfig</code> flag:</p>

<pre><code>aretext -editconfig
</code></pre>

<p>The configuration file is located at <code>$XDG_CONFIG_HOME/aretext/config.yaml</code>, where <code>XDG_CONFIG_HOME</code> is configured according to the <a href="https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html">XDG Base Directory Specification</a>. On Linux, this defaults to <code>~/.config</code>, and on macOS it defaults to <code>~/Library/Application Support</code>.</p>

<p>When you open the config file, you should see something like:</p>

<pre><code>- name: default
  pattern: &quot;**&quot;
  config:
    autoIndent: false
    hideDirectories: [&quot;.git&quot;]
    syntaxLanguage: plaintext
    tabExpand: false
    tabSize: 4
    showLineNumbers: false

- name: json
  pattern: &quot;**/*.json&quot;
  config:
    autoIndent: true
    syntaxLanguage: json
    tabExpand: true
    tabSize: 2
    showLineNumbers: true
</code></pre>

<p>Each item in the configuration file describes a <em>rule</em>. For example, in the snippet above, the first rule is named &quot;default&quot; and the second rule is named &quot;json&quot;.</p>

<p>Each rule has a <em>pattern</em>. The &quot;**&quot; is a wildcard that matches any subdirectory, and &quot;*&quot; is a wildcard that matches zero or more characters in a file or directory name.</p>

<p>When aretext loads a file, it checks each rule in order. If the rule's pattern matches the file's absolute path, it applies the rule to update the configuration.</p>

<p>For example, if aretext loaded the file &quot;foo/bar.json&quot; using the above configuration, both rules would match the filename. The resulting configuration would be:</p>

<pre><code>config:
    autoIndent: true           # from the &quot;json&quot; rule
    hideDirectories: [&quot;.git&quot;]  # from the &quot;default&quot; rule
    syntaxLanguage: json       # from the &quot;json&quot; rule
    tabExpand: true            # from the &quot;json&quot; rule
    tabSize: 2                 # from the &quot;json&quot; rule
    showLineNumbers: true      # from the &quot;json&quot; rule
</code></pre>

<p>When merging configurations from different rules:</p>

<ul>
<li>For strings and numbers, the values from later rules overwrite the values from previous rules.</li>
<li>For lists, the values from all rules are combined.</li>
<li>For dictionaries, the keys from later rules are added to the merged dictionary, potentially overwriting keys set by previous rules.</li>
</ul>

<p>This is a powerful mechanism for customizing configuration based on filename extension and/or project location. For example, suppose that one project you work on uses four spaces to indent JSON files. You could add a new rule to your config that overwrites the tabSize for JSON files in that specific project:</p>

<pre><code># ... other rules above ...
- name: myproject-json
  pattern: &quot;**/myproject/**/*.json&quot;
  config:
    tabSize: 4
</code></pre>

<h2 id="configuration-reference">Configuration Reference</h2>

<p>For a complete list of available configuration options, see <a href="config-reference.html">Configuration Reference</a>.</p>

<h2 id="fixing-configuration-errors">Fixing configuration errors</h2>

<p>If your YAML config file has errors, aretext will exit with an error message. You can force aretext to ignore the config file by passing the &quot;-noconfig&quot; flag:</p>

<pre><code>aretext -editconfig -noconfig
</code></pre>

<p>This allows you to start the editor so you can fix the configuration.</p>

<h2 id="custom-menu-commands">Custom menu commands</h2>

<p>Aretext allows you to define custom menu items to run shell commands. This provides a simple, yet powerful, way to extend aretext.</p>

<p>You can add new menu commands by editing the config file:</p>

<pre><code>- name: custom-menu-rule
  pattern: &quot;**/myproject/**&quot;
  config:
    menuCommands:
      - name: my custom menu command
        shellCmd: echo 'hello world!' | less
        mode: terminal  # or &quot;silent&quot; or &quot;insert&quot; or &quot;fileLocations&quot;
</code></pre>

<p>After restarting the editor, the new command will be available in the command menu. Selecting the new command will launch a shell (configured by the <code>$SHELL</code> environment variable) and execute the shell command (in this case, echoing &quot;hello world&quot;).</p>

<p>The &quot;mode&quot; parameter controls how aretext handles the command's input and output. There are four modes:</p>

<table>
<thead>
<tr>
<th>Mode</th>
<th>Input</th>
<th>Output</th>
<th>Use Cases</th>
</tr>
</thead>

<tbody>
<tr>
<td>terminal</td>
<td>tty</td>
<td>tty</td>
<td><code>make</code>, <code>git commit</code>, <code>go test</code>, <code>man</code>, ...</td>
</tr>

<tr>
<td>silent</td>
<td>none</td>
<td>none</td>
<td><code>go fmt</code>, tmux commands, copy to system clipboard, ...</td>
</tr>

<tr>
<td>insert</td>
<td>none</td>
<td>insert into document</td>
<td>paste from system clipboard, insert snippet, comment/uncomment selection, ...</td>
</tr>

<tr>
<td>fileLocations</td>
<td>none</td>
<td>file location menu</td>
<td>grep for word under cursor, ...</td>
</tr>
</tbody>
</table>
<p>In addition, the following environment variables are provided to the shell command:</p>

<ul>
<li><code>$FILEPATH</code> is the absolute path to the current file.</li>
<li><code>$WORD</code> is the current word under the cursor.</li>
<li><code>$SELECTION</code> is the currently selected text (if any).</li>
</ul>

<h3 id="example-make">Example: Make</h3>

<p>Add a menu command to build a project using <code>make</code>. Piping to <code>less</code> allows us to page through the output.</p>

<pre><code>- name: custom-make-cmd
  pattern: &quot;**/myproject/**&quot;
  config:
    menuCommands:
      - name: build
        shellCmd: make | less
        # default mode is &quot;terminal&quot;
</code></pre>

<h3 id="example-copy-and-paste-using-the-system-clipboard">Example: Copy and paste using the system clipboard</h3>

<p>Most systems provide command-line utilities for interacting with the system clipboard.</p>

<table>
<thead>
<tr>
<th>System</th>
<th>Commands</th>
</tr>
</thead>

<tbody>
<tr>
<td>Linux using XWindows</td>
<td><code>xclip</code></td>
</tr>

<tr>
<td>Linux using Wayland</td>
<td><code>wl-copy</code>, <code>wl-paste</code></td>
</tr>

<tr>
<td>macOS</td>
<td><code>pbcopy</code>, <code>pbpaste</code></td>
</tr>

<tr>
<td>WSL on Windows</td>
<td><code>clip.exe</code>, <code>powershell Get-Clipboard</code></td>
</tr>

<tr>
<td>tmux</td>
<td><code>tmux set-buffer</code>, <code>tmux show-buffer</code></td>
</tr>
</tbody>
</table>
<p>We can add custom menu commands to copy the current selection to the system clipboard and paste from the system clipboard into the document.</p>

<p>On Linux (Wayland):</p>

<pre><code>- name: linux-wayland-clipboard-commands
  pattern: &quot;**&quot;
  config:
    menuCommands:
      - name: copy to clipboard
        shellCmd: wl-copy &quot;$SELECTION&quot;
        mode: silent
      - name: paste from clipboard
        shellCmd: wl-paste
        mode: insert
</code></pre>

<p>On macOS:</p>

<pre><code>- name: macos-clipboard-commands
  pattern: &quot;**&quot;
  config:
    menuCommands:
      - name: copy to clipboard
        shellCmd: printenv SELECTION | pbcopy
        mode: silent
      - name: paste from clipboard
        shellCmd: pbpaste
        mode: insert
</code></pre>

<p>Using tmux:</p>

<pre><code>- name: tmux-clipboard-commands
  pattern: &quot;**&quot;
  config:
    menuCommands:
    - name: copy to clipboard
      shellCmd: printenv SELECTION | tmux load-buffer -
      mode: silent
    - name: paste from clipboard
      shellCmd: tmux show-buffer
      mode: insert
</code></pre>

<h3 id="example-format-current-file">Example: Format current file</h3>

<p>Many programming languages provide command line tools to automatically format code. You can add a custom menu command to run these tools on the current file.</p>

<p>For example, this command uses <code>go fmt</code> to format a Go file:</p>

<pre><code>- name: custom-fmt-command
  pattern: &quot;**/*.go&quot;
  config:
    menuCommands:
      - name: go fmt current file
        shellCmd: go fmt $FILEPATH | less
</code></pre>

<p>If there are no unsaved changes, aretext will automatically reload the file after it has been formatted.</p>

<h3 id="example-insert-snippet">Example: Insert snippet</h3>

<p>You can add a custom menu command to insert a snippet of code.</p>

<p>For example, suppose you have written a template for a Go test. You can then create a menu command to <code>cat</code> the contents of the file into the document:</p>

<pre><code>- name: custom-snippet-command
  pattern: &quot;**/*.go&quot;
  config:
    menuCommands:
      - name: insert test snippet
        shellCmd: cat ~/snippets/go-test.go
        mode: insert
</code></pre>

<h3 id="example-grep">Example: Grep</h3>

<p>You can add a custom menu command to grep for the word under the cursor. The following example uses <a href="https://github.com/BurntSushi/ripgrep">ripgrep</a> to perform the search:</p>

<pre><code>- name: custom-grep-command
  pattern: &quot;**&quot;
  config:
    menuCommands:
      - name: rg word
        shellCmd: rg $WORD --vimgrep  # or `grep $WORD -n -R .`
        mode: fileLocations
</code></pre>

<p>Once the search has completed, aretext loads the locations into a searchable menu. This allows you to easily navigate to a particular result.</p>

<p>The &quot;fileLocations&quot; mode works with any command that outputs file locations as lines with the format: <code>&lt;file&gt;:&lt;line&gt;:&lt;snippet&gt;</code> or <code>&lt;file&gt;:&lt;line&gt;:&lt;col&gt;:&lt;snippet&gt;</code>. You can use grep, ripgrep, or a script you write yourself!</p>

<h3 id="example-split-tmux-window">Example: Split tmux window</h3>

<p>If you use <a href="https://wiki.archlinux.org/title/Tmux">tmux</a>, you can add a custom menu command to open the current document in a new window.</p>

<pre><code>- name: split window horizontal
  shellCmd: tmux split-window -h &quot;aretext $FILEPATH&quot;
  mode: silent
- name: split window vertical
  shellCmd: tmux split-window -v &quot;aretext $FILEPATH&quot;
  mode: silent
</code></pre>

</body>
</html>
