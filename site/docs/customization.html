<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <link rel="stylesheet" type="text/css" href="/style.css">
  <link rel="icon" type="image/x-icon" href="data:,">
  <title>aretext : customization</title>
</head>
<body>
<h1>Customization</h1>

<p>This guide describes how to customize aretext for your workflows.</p>

<h2>Configuration rules</h2>

<p>Aretext stores its configuration in a single YAML file located at <code>~/.config/aretext/config.yaml</code>. If you open it, you should see something like this:</p>

<pre><code>- name: default
  pattern: &quot;**&quot;
  config:
    autoIndent: false
    hideDirectories: [&quot;.git&quot;]
    syntaxLanguage: plaintext
    tabExpand: false
    tabSize: 4
    showLineNumbers: false

- name: json
  pattern: &quot;**/*.json&quot;
  config:
    autoIndent: true
    syntaxLanguage: json
    tabExpand: true
    tabSize: 2
    showLineNumbers: true
</code></pre>

<p>Each item in the configuration file describes a <em>rule</em>. For example, in the snippet above, the first rule is named &quot;default&quot; and the second rule is named &quot;json&quot;.</p>

<p>Each rule has a <em>pattern</em>. The &quot;**&quot; is a wildcard that matches any subdirectory, and &quot;*&quot; is a wildcard that matches zero or more characters in a file or directory name.</p>

<p>When aretext loads a file, it checks each rule in order. If the rule's pattern matches the file path, it applies the rule to update the configuration.</p>

<p>For example, if aretext loaded the file &quot;foo/bar.json&quot; using the above configuration, both rules would match the filename. The resulting configuration would be:</p>

<pre><code>config:
    autoIndent: true           # from the &quot;json&quot; rule
    hideDirectories: [&quot;.git&quot;]  # from the &quot;default&quot; rule
    syntaxLanguage: json       # from the &quot;json&quot; rule
    tabExpand: true            # from the &quot;json&quot; rule
    tabSize: 2                 # from the &quot;json&quot; rule
    showLineNumbers: true      # from the &quot;json&quot; rule
</code></pre>

<p>When merging configurations from different rules:</p>

<ul>
<li>For strings and numbers, the values from later rules overwrite the values from previous rules.</li>
<li>For lists, the values from all rules are combined.</li>
<li>For dictionaries, the keys from later rules are added to the merged dictionary, potentially overwriting keys set by previous rules.</li>
</ul>

<p>This is a powerful mechanism for customizing configuration based on filename extension and/or project location. For example, suppose that one project you work on uses four spaces to indent JSON files. You could add a new rule to your config that overwrites the tabSize for JSON files in that specific project:</p>

<pre><code># ... other rules above ...
- name: myproject-json
  pattern: &quot;**/myproject/**/*.json&quot;
  config:
    tabSize: 4
</code></pre>

<h2>Fixing configuration errors</h2>

<p>If your YAML config file has errors, aretext will exit with an error message. You can force aretext to ignore the config file by passing the &quot;-noconfig&quot; flag:</p>

<pre><code>aretext -noconfig ~/.config/aretext/config.yaml
</code></pre>

<p>This allows you to start the editor so you can fix the configuration.</p>

<h2>Custom menu commands</h2>

<p>Aretext allows you to define custom menu items to run shell commands. This provides a simple, yet powerful, way to extend aretext.</p>

<p>You can add new menu commands by editing the YAML config file at <code>~/.config/aretext/config.yaml</code>:</p>

<pre><code>- name: custom-menu-rule
  pattern: &quot;**/myproject/**&quot;
  config:
    menuCommands:
      - name: my custom menu command
        shellCmd: echo 'hello world!' | less
        mode: terminal  # or &quot;silent&quot; or &quot;insert&quot; or &quot;fileLocations&quot;
</code></pre>

<p>After restarting the editor, the new command will be available in the command menu. Selecting the new command will launch a shell (configured by the <code>$SHELL</code> environment variable) and execute the shell comand (in this case, echoing &quot;hello world&quot;).</p>

<p>The &quot;mode&quot; parameter controls how aretext handles the command's input and output. There are four modes:</p>

<table>
<thead>
<tr>
<th>Mode</th>
<th>Input</th>
<th>Output</th>
<th>Use Cases</th>
</tr>
</thead>

<tbody>
<tr>
<td>terminal</td>
<td>tty</td>
<td>tty</td>
<td><code>make</code>, <code>git commit</code>, <code>go test</code>, <code>man</code>, ...</td>
</tr>

<tr>
<td>silent</td>
<td>none</td>
<td>none</td>
<td><code>go fmt</code>, tmux commands, copy to system clipboard, ...</td>
</tr>

<tr>
<td>insert</td>
<td>none</td>
<td>insert into document</td>
<td>paste from system clipboard, insert snippet, comment/uncomment selection, ...</td>
</tr>

<tr>
<td>fileLocations</td>
<td>none</td>
<td>file location menu</td>
<td>grep for word under cursor, ...</td>
</tr>
</tbody>
</table>
<p>In addition, the following environment variables are provided to the shell command:</p>

<ul>
<li><code>$FILEPATH</code> is the absolute path to the current file.</li>
<li><code>$WORD</code> is the current word under the cursor.</li>
<li><code>$SELECTION</code> is the currently selected text (if any).</li>
</ul>

<h3>Example: Make</h3>

<p>Add a menu command to build a project using <code>make</code>. Piping to <code>less</code> allows us to page through the output.</p>

<pre><code>- name: custom-make-cmd
  pattern: &quot;**/myproject/**&quot;
  config:
    menuCommands:
      - name: build
        shellCmd: make | less
        # default mode is &quot;terminal&quot;
</code></pre>

<h3>Example: Copy/paste using the system clipboard</h3>

<p>Most systems provide command-line utilities for interacting with the system clipboard.</p>

<table>
<thead>
<tr>
<th>System</th>
<th>Commands</th>
</tr>
</thead>

<tbody>
<tr>
<td>Linux using XWindows</td>
<td><code>xclip</code></td>
</tr>

<tr>
<td>Linux using Wayland</td>
<td><code>wl-copy</code>, <code>wl-paste</code></td>
</tr>

<tr>
<td>macOS</td>
<td><code>pbcopy</code>, <code>pbpaste</code></td>
</tr>

<tr>
<td>WSL on Windows</td>
<td><code>clip.exe</code>, <code>powershell Get-Clipboard</code></td>
</tr>

<tr>
<td>tmux</td>
<td><code>tmux set-buffer</code>, <code>tmux show-buffer</code></td>
</tr>
</tbody>
</table>
<p>We can add custom menu commands to copy the current selection to the system clipboard and paste from the system clipboard into the document. For example, on Wayland:</p>

<pre><code>- name: custom-clipboard-commands
  pattern: &quot;**&quot;
  config:
    menuCommands:
      - name: copy to clipboard
        shellCmd: wl-copy &quot;$SELECTION&quot;
        mode: silent
      - name: paste from clipboard
        shellCmd: wl-paste
        mode: insert
</code></pre>

<h3>Example: Format current file</h3>

<p>Many programming languages provide command line tools to automatically format code. You can add a custom menu command to run these tools on the current file.</p>

<p>For example, this command uses <code>go fmt</code> to format a Go file:</p>

<pre><code>- name: custom-fmt-command
  pattern: &quot;**/*.go&quot;
  config:
    menuCommands:
      - name: go fmt current file
        shellCmd: go fmt -w $FILEPATH | less
</code></pre>

<p>If there are no unsaved changes, aretext will automatically reload the file after it has been formatted.</p>

<h3>Example: Insert snippet</h3>

<p>You can add a custom menu command to insert a snippet of code.</p>

<p>For example, suppose you have written a template for a Go test. You can then create a menu command to <code>cat</code> the contents of the file into the document:</p>

<pre><code>- name: custom-snippet-command
  pattern: &quot;**/*.go&quot;
  config:
    - name: insert test snippet
      shellCmd: cat ~/snippets/go-test.go
      mode: insert
</code></pre>

<h3>Example: Grep</h3>

<p>You can add a custom menu command to grep for the word under the cursor. The following example uses <a href="https://github.com/BurntSushi/ripgrep">ripgrep</a> to perform the search:</p>

<pre><code>- name: custom-grep-command
  pattern: &quot;**&quot;
  config:
    - name: rg word
      shellCmd: rg $WORD --vimgrep
      mode: fileLocations
</code></pre>

<p>Once the search has completed, aretext loads the locations into a searchable menu. This allows you to easily navigate to a particular result.</p>

<p>The &quot;fileLocations&quot; mode works with any command that outputs file locations as lines with the format: <code>&lt;file&gt;:&lt;line&gt;:&lt;snippet&gt;</code> or <code>&lt;file&gt;:&lt;line&gt;:&lt;col&gt;:&lt;snippet&gt;</code>. You can use grep, ripgrep, or a script you write yourself!</p>

</body>
</html>
